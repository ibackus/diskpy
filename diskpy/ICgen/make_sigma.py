# -*- coding: utf-8 -*-
"""
Calculates cubic spline interpolations for sigma(r) and probability(r)
probability = 2*pi*r*sigma

Created on Mon Jan 27 13:00:52 2014

@author: ibackus
"""
# ICgen packages
from diskpy.utils import match_units

# External packages
import pynbody
SimArray = pynbody.array.SimArray

import numpy as np
from scipy.interpolate import interp1d
#from scipy.interpolate import InterpolatedUnivariateSpline as spline
from _compatible_spline import spline
from scipy.integrate import quad, cumtrapz
from scipy.integrate import simps
import copy as copier

class sigma_gen:
    """
    A class to generate the surface density (sigma), probability density (pdf)
    and inverse cumulative distribution function (cdf_inv) as a function of r
    
    USAGE:
    
    # Generate sigma (settings is generated by ICgen_settings.py, see below)
    
    import make_sigma
    sigma = make_sigma.sigma_gen(r, sigma)
    
    # Calculate at various r positions:
    
    sigma(r)    # returns sigma evaluated at r
    sigma.sigma(r)  # returns sigma evaluated at r
    pdf = sigma.pdf(r)  # returns pdf evaluated at r
    cdf_inv = sigma.cdf_inv(m) # returns cdv_inv at m for 0 < m < 1
    
    # Generate sigma with a precalulated CDF (as done before)
    
    sigma = make_sigma.sigma_gen(r, sigma, CDF)
    
    """
    
    def __init__(self, r_bins, sigmaBinned, CDF=None):
        
        self.input_dict = {'r': r_bins, 'sigma': sigmaBinned}
        self._make_sigma(r_bins, sigmaBinned)
        self._make_pdf()
        self._make_cdf_inv(CDF)
        self._disk_mass()
        
    def __call__(self, r):
        
        return self.sigma(r)
        
    def _make_sigma(self, r_bins, sigmaBinned):
        """
        Generates the surface density as a function of r, a callable object 
        sigma(r) and assigns it to self.sigma
        
        Generates a spline interpolation of sigma vs r from the file
        defined by settings.filenames.sigmaFileName.  Returns sigma vs r as
        an cubic spline interpolation object
        (see scipy.interpolation.InterpolatedUnivariateSpline)
        
        sigma_input should be a pickled dictionary with the entries:
        'sigma': <sigma evaluated at r>
        'r':     <r for the bins>
        
        If the input sigma has units, sigma vs r will be returned in units
        of Msol/au^2
        """       
        # Convert to default units of Msol/au^2.  If no units, assign default
        sigmaBinned = match_units(sigmaBinned, 'Msol au**-2')[0]
        # Convert r_bins to default units of 'au'
        r_bins = match_units(r_bins, 'au')[0]
        # Calculate spline interpolation
        sigspline = spline(r_bins, sigmaBinned, k=3, ext='zeros')
#        print 'Calculating spline interpolation (slow for many data points)'
#        sigspline = interp1d(r_bins,sigmaBinned,kind='cubic',fill_value=0.0,\
#        bounds_error=False)
        
        def sigout(r):
            """
            Linear spline interpolation of sigma(r).  
            
            ARGUMENTS:
            
            r - can be scalar, numpy array, or sim array
            
            RETURNS: 
            
            sigma (surface density) evaluated at r
            """
            
            # Try to convert r to the units used to make sigspline ('au')
            r = match_units(r, 'au')[0]
            
            return SimArray(sigspline(r), 'Msol au**-2')
        
        self.sigma = sigout
        self.r_bins = r_bins
        
    def _make_pdf(self):
        """
        Generates the probability density as a function of r (from the surface
        density) and returns it as a callable function pdf(r) to self.pdf
        pdf(r) = 2*pi*r*sigma(r), up to a normalization
        
        Using sigma(r) calculated in _make_sigma and r_bins loaded from
        settings.filenames.sigmaFileName, creates an interpolation over
        r_bins, sigma(r_bins).  The PDF will be approximately normalized
            
        """
            
        # Calculate the binned PDF
        pdfBinned = 2*np.pi*self.r_bins * self.sigma(self.r_bins)
        # Normalize
        integral = simps(pdfBinned,self.r_bins)
        pdfBinned /= integral
        # Calculate a spline interpolation
        pdfSpline = spline(self.r_bins, pdfBinned, k=3, ext='zeros')
#        print 'Calculating spline interpolation (slow for many data points)'
#        pdfSpline = interp1d(self.r_bins, pdfBinned, kind='cubic',\
#        fill_value=0.0, bounds_error=False)
        
        def pdf_fcn(r_in):
            """
            Normalized cubic spline interpolation of the PDF(r) from sigma(r).
            The PDF is just calculated as 2*pi*r*sigma(r).
            
            ARGUMENTS:
            
            r_in - radii at which to calculate the PDF
            
            RETURNS:
            
            probability density function from sigma(r) evaluated at r_in
            """
            # Put r_in into the units used in generating the pdf
            r_in = match_units(r_in, self.r_bins)[0]
            # Evaluate the pdf at r_in
            pdf_vals = pdfSpline(r_in)
            # Put the pdf into units of r_in.units**-1
            pdf_vals = match_units(pdf_vals, 1/r_in)[0]
            
            return pdf_vals
            
        self.pdf = pdf_fcn
        
    def _make_cdf_inv(self, f=None):
        """
        Calculates the inverse of the CDF (cumulative distribution function).
        This can be use for generating particle positions.  Generates a 
        callable method and saves to self.cdf_inv
        
        The CDF_inv is made by cumulatively integrating the PDF over the radial
        bins defined in self.r_bins
        
        The optional argument, f, is ignored
            
        """
        
        # calculate the binned PDF
        r = self.r_bins
        pdf = self.pdf(r)
        # Calculate the (normalized) CDF
        cdf = cumtrapz(abs(pdf), r, initial=0)
        cdf /= cdf.max()
        # For compatability, save cdf
        self._CDF = cdf
        
        # Make a callable, interpolate function for the CDF
        cdfinv_spl = interp1d(cdf, r, kind='linear')
        
        def finv_fcn(m):
            """
            The inverse CDF for sigma(r).
            
            input:
            
            0 <= m_in < 1
            
            returns:
            
            r (radius), the inverse CDF evaluated at m_in
            
            Uses a linear spline interpolation.
            """
            rout = cdfinv_spl(m)
            return SimArray(rout, r.units)
            
        self.cdf_inv = finv_fcn
        
            
    def _make_cdf_invOLD(self, f=None):
        """
        Calculates the inverse of the CDF (cumulative distribution function).
        This can be use for generating particle positions.  Generates a 
        callable method and saves to self.cdf_inv
        
        The CDF_inv is made by cumulatively integrating the PDF over the radial
        bins defined in self.r_bins
        
        The optional argument, f, is the CDF binned over the radial bins
            
        """
        print 'calculating CDF'
        # Calculate the CDF from prob
        r = self.r_bins
        r[0] = 0.0
        nr = len(r)
        
        if f is None:
            
            f = np.zeros(nr)
            
            for n in range(nr):
                
                f[n] = quad(self.pdf,r[[0]],r[[n]])[0]
                
            f /= f.max()
        
        self._CDF = f.copy()
        
        print 'calculating inverse CDF'
        # Calculate the inverse CDF.
        # Assume CDF is approximately monotonic and sort to force it to be
        ind = f.argsort()
        f = f[ind]
        r = r[ind]
        # Drop values where CDF is constant (ie, prob = 0)
        mask = np.ones(nr,dtype='bool')
        for n in range(1,nr):
            if f[n] == f[n-1]:
                mask[n] = False
        f = f[mask]
        r = r[mask]
        finv = interp1d(f,r,kind='linear')
        
        def finv_fcn(m_in):
            """
            The inverse CDF for sigma(r).
            
            input:
            
            0 <= m_in < 1
            
            returns:
            
            r (radius), the inverse CDF evaluated at m_in
            
            Uses a linear spline interpolation.
            """
            
            r_out = finv(m_in)
            r_out = match_units(r_out, r)[0]
            return r_out
        
        self.cdf_inv = finv_fcn
            
    def _disk_mass(self):
        """
        Calculate the total disk mass by integrating sigma
        """
        # Assign variables
        r = self.r_bins
        sig = self.sigma(r)
        # Now integrate
        m_disk = simps(2*np.pi*r*sig, r)
        m_units = sig.units * (r.units)**2
        m_disk = match_units(m_disk, m_units)[0]
        
        self.m_disk = m_disk
            
        
    def copy(self):
        """
        Returns a copy of the sigma object
        """
        return copier.copy(self)
        